#!/bin/bash

DEFAULT_CA_DIR=$(pwd)/dice-root-ca
DEFAULT_CFG_OUT=dice-root-ca_openssl.cnf
DEFAULT_YUBI="false"
DEFAULT_PIN=123456
DEFAULT_PKCS=/usr/lib/x86_64-linux-gnu/libykcs11.so
# NOTE: We do not support using slot 9c. This slot, per the spec, is supposed
# to require pin entry on each use. Openssl takes this pretty seriously and
# will ignore the pin provided in the config file. There doesn't seem to be
# consensus as to whether this is a bug or a feature.
# https://bugzilla.redhat.com/show_bug.cgi?id=1728016
# https://stackoverflow.com/questions/57729106/how-to-pass-yubikey-pin-to-openssl-command-in-shell-script
DEFAULT_SLOT=9a

print_usage ()
{
    cat <<END
Usage: $0
    [ --cfg-out - path to output openssl cfg (DEFAULT: $DEFAULT_CFG_OUT) ]
    [ --dir - root directory for CA files / cfg (DEFAULT: $DEFAULT_CA_DIR) ]
    [ --yubi - do key operations on a yubikey (DEFAULT: false) ]
    NOTE: the following options only apply when \'--yubikey\' is provided
    [ --pkcs11 - path to shared library implementing PKCS#11 (DEFAULT: $DEFAULT_PKCS) ]
    [ --slot - PIV slot for key, allowed values: (9a | 9d) (DEFAULT: $DEFAULT_SLOT) ]
    [ --pin - PIN required for key generation (DEFAULT: $DEFAULT_PIN) ]
    [ -h | --help  ]
END

    exit 2
}

print_help ()
{
    print_usage
    exit 0
}

usage_error ()
{
    >&2 echo "$1"
    print_usage
    exit 2
}

while test $# -gt 0; do
    case $1 in
    -h|--help) print_help; exit $?;;
    -d|--dir) CA_DIR=$2; shift;;
    -d=*|--dir=*) CA_DIR="${1#*=}";;
    -c|--cfg-out) CFG_OUT=$2; shift;;
    -c=*|--cfg-out=*) CFG_OUT="${1#*=}";;
    -y|--yubi) YUBI="true";;
    -p|--pin) PIN=$2; shift;;
    -p=*|--pin=*) PIN="${1#*=}";;
    -l|--slot) SLOT=$2; shift;;
    -l=*|--slot=*) SLOT="${1#*=}";;
    -k|--pkcs11) PKCS=$2; shift;;
    -k=*|--pkcs11=*) PKCS="${1#*=}";;
    -o|--archive-prefix) ARCHIVE_PREFIX=$2; shift;;
    -o=*|--archive-prefix=*) ARCHIVE_PREFIX="${1#*=}";;
     --) shift; break;;
    -*) usage_error "invalid option: '$1'";;
     *) break;;
    esac
    shift
done

# defaults if not set via options or env
if [ -z ${CA_DIR+x} ]; then
    CA_DIR=$DEFAULT_CA_DIR
fi
if [ -z ${CFG_OUT+x} ]; then
    CFG_OUT=$DEFAULT_CFG_OUT
fi

# don't check too hard
if [ -z ${YUBI+x} ]; then
    YUBI=$DEFAULT_YUBI
fi
if [ -z ${PIN+x} ]; then
    PIN=$DEFAULT_PIN
fi
if [ -z ${PKCS+x} ]; then
    PKCS=$DEFAULT_PKCS
fi
if [ -z ${SLOT+x} ]; then
    SLOT=$DEFAULT_SLOT
fi

OPENSSL_CERT=certs/ca.cert.pem
CERT=$CA_DIR/$OPENSSL_CERT

# multiple yubikeys / PIV devices would require identifying the slot too?
if [ $YUBI = "false" ]; then
    OPENSSL_KEY="\$dir/private/ca.key.pem"
    KEY=$CA_DIR/private/ca.key.pem
    # assume ed25519
    HASH=sha3-256
else
    case $SLOT in
        9a) OPENSSL_KEY="slot_0-id_1";;
        9d) OPENSSL_KEY="slot_0-id_3";;
        *) usage_error "invalid slot";;
    esac
    KEY=$OPENSSL_KEY
    # assume eccp384
    HASH=sha384
    if [ -z ${ARCHIVE_PREFIX+x} ]; then
        >&2 echo "missing required argument: --archive-prefix"
	exit 1
    else
        ARCHIVE_FILE=${ARCHIVE_PREFIX}.tar.xz
    fi
fi
if [ -z ${SUBJECT+x} ]; then
    SUBJECT=$DEFAULT_SUBJECT
fi

set -e

mkdir -p $CA_DIR
pushd $CA_DIR > /dev/null
# Using absolute path makes the openssl.cnf flexible / usable from somewhere
# other than $CA_DIR. The down side: if you move CA_DIR you will need to
# update 'dir' in openssl.cnf.
CA_DIR=$(pwd)
mkdir certs crl csr newcerts private
chmod 700 private
touch index.txt
echo 1000 > serial
popd > /dev/null

set +e

echo "# generated by $0" > $CFG_OUT

# config necessary to communicate with the yubikey
# TODO: possible to bind config to yubikey (by serial # etc)?
if [ $YUBI = "true" ]; then
cat << EOF >> $CFG_OUT
openssl_conf = openssl_init

[openssl_init]
engines = engine_section

[engine_section]
pkcs11 = pkcs11_section

[pkcs11_section]
engine_id = pkcs11
MODULE_PATH = $PKCS
PIN = $PIN

EOF
fi

# config necessary to:
# - create CSR for intermediate CA
# - create & sign x509 DeviceId certs
# TODO: slim this down / wtf is all this?
cat << EOF >> $CFG_OUT
[ ca ]
default_ca = ca_default

[ ca_default ]
# Directory and file locations.
dir               = $CA_DIR
certs             = \$dir/certs
crl_dir           = \$dir/crl
new_certs_dir     = \$dir/newcerts
database          = \$dir/index.txt
serial            = \$dir/serial
RANDFILE          = \$dir/private/.rand
private_key       = $OPENSSL_KEY
certificate       = \$dir/$OPENSSL_CERT

name_opt          = ca_default
cert_opt          = ca_default
default_days      = 3650
default_md        = $HASH
preserve          = no
policy            = policy_strict
x509_extensions   = v3_ca

[ policy_strict ]
countryName             = match
stateOrProvinceName     = match
localityName            = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
serialNumber            = optional
emailAddress            = optional

[ req ]
distinguished_name  = req_distinguished_name
string_mask         = utf8only
x509_extensions     = v3_ca

[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
serialNumber                    = Serial Number

countryName_default             = US
stateOrProvinceName_default     = California
localityName_default            = Emeryville
0.organizationName_default      = Oxide Computer Company
organizationalUnitName_default  = Manufacturing

[ v3_ca ]
basicConstraints = critical, CA:true
keyUsage = critical, keyCertSign
EOF

SUBJECT="/C=US/ST=California/L=Emeryville/O=Oxide Computer Company/OU=Manufacturing/CN=root-ca"

TMP_DIR=$(mktemp -d -t ${0##*/}-XXXXXXXXXX)
LOG=$TMP_DIR/out.log

# do_keygen_$yubi
do_keygen_false ()
{
    # key for CA signing operations: path is used in openssl.cnf
    echo -n "Generating ed25519 key in file \"$KEY\" ... "
    openssl genpkey \
        -algorithm ED25519 \
        -out $KEY > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi
}

do_keygen_true ()
{
    local PUB=$TMP_DIR/pub.pem

    echo -n "Generating ECCP384 key in slot \"$SLOT\" with provided pin ... "
    yubico-piv-tool \
        --action verify-pin \
        --pin $PIN \
        --action generate \
        --slot $SLOT \
        --algorithm ECCP384 \
        --output $PUB > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi
}

do_keygen_$YUBI

# do_selfsign_$yubi
do_selfsign_false ()
{
    echo -n "Generating self signed cert using $HASH & subject: \"$SUBJECT\" ... "
    openssl req \
        -config $CFG_OUT \
        -subj "$SUBJECT" \
        -key $KEY \
        -new \
        -x509 \
        -extensions v3_ca \
	-sha3-256 \
        -out $CERT > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi
}

do_selfsign_true ()
{
    # everything in this directory will be rolled up into $ARCHIVE_FILE
    local ARCHIVE_DIR=$TMP_DIR/$ARCHIVE_PREFIX
    mkdir -p $ARCHIVE_DIR

    echo -n "Generating self signed cert w/ subject: \"$SUBJECT\" ... "
    OPENSSL_CONF=$CFG_OUT \
    openssl req \
        -new \
        -x509 \
        -engine pkcs11 \
        -keyform engine \
        -key $KEY \
        -sha384 \
        -out $CERT \
        -subj "$SUBJECT" > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi

    echo -n "Importing cert from \"$CERT\" to slot \"$SLOT\" ... "
    yubico-piv-tool \
        --action import-certificate \
        --slot $SLOT \
        --input $CERT > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi
    
    local CERT_TMP=$ARCHIVE_DIR/ca.cert.pem

    echo -n "Reading cert back from slot \"$SLOT\" ... "
    yubico-piv-tool \
        --action read-certificate \
        --slot $SLOT \
        --output $CERT_TMP > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi
    
    echo -n "Checking cert consistency ... "
    if cmp $CERT_TMP $CERT; then
        echo "success"
    else
        echo "failure"
        exit 1
    fi

    local ATTEST_INT_CERT=$ARCHIVE_DIR/attest-intermediate.cert.pem
    echo -n "Getting attestation intermediate cert from slot \"f9\" ... "
    yubico-piv-tool \
        --action read-certificate \
	--slot f9 \
	--output $ATTEST_INT_CERT > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi

    local ATTEST_CERT=$ARCHIVE_DIR/attest-leaf.cert.pem
    echo -n "Generating attestation for key in slot \"$SLOT\" ... "
    yubico-piv-tool \
        --action attest \
        --slot $SLOT \
	--output $ATTEST_CERT > $LOG 2>&1
    if [ $? -eq 0 ]; then
        echo "success"
    else
        echo "failure"
        cat $LOG
        exit 1
    fi

    # generate script to evaluate attestation
    local VERIFY_SH=$ARCHIVE_DIR/verify-attestation.sh
    cat << EOF > $VERIFY_SH
#!/bin/sh

NAME=\${0##*/}
TMP_DIR=\$(mktemp -d -t \${0##*/}-XXXXXXXX)
LOG=\$TMP_DIR/\$NAME
ATTEST_ROOT_CERT=\$TMP_DIR/attest-root.cert.pem
ATTEST_ROOT_URL="https://developers.yubico.com/PIV/Introduction/piv-attestation-ca.pem"

echo -n "Getting attestation root cert from yuboco.com ... "
wget --output-document \$ATTEST_ROOT_CERT \$ATTEST_ROOT_URL > \$LOG 2>&1
if [ \$? -eq 0 ]; then
    echo "success"
else
    echo "failure"
    cat \$LOG
    exit 1
fi

ATTEST_CERT=$(basename $ATTEST_CERT)
ATTEST_INT_CERT=$(basename $ATTEST_INT_CERT)
AWK_CMD="BEGIN { out=0 } /ASN1 OID:/ { out=0 } // { if (out == 1) print \\\$0 } /pub:/ { out=1 }"

echo -n "Verifying attestation signature ... "
openssl verify -CAfile \$ATTEST_ROOT_CERT -untrusted \$ATTEST_INT_CERT \$ATTEST_CERT > \$LOG 2>&1
if [ \$? -eq 0 ]; then
    echo "success"
else
    echo "failure"
    cat \$LOG
    exit 1
fi

CA_CERT=$(basename $CERT)

echo -n "Ensuring public key in attestation matches the CA cert ... "
PUB_CERT=\$(openssl x509 \
    -in \$CA_CERT \
    -noout \
    -text 2> /dev/null \
| awk "\$AWK_CMD" \
| tr -d " \t\n\r:")
PUB_ATTEST=\$(openssl x509 \
    -in \$ATTEST_CERT \
    -noout \
    -text 2> /dev/null \
| awk "\$AWK_CMD" \
| tr -d " \t\n\r:")
if [ "\$PUB_CERT" = "\$PUB_ATTEST" ]; then
    echo "success"
else
    echo "failure"
    cat \$LOG
    exit 1
fi

EOF
    chmod 755 $VERIFY_SH

    local ATTEST_README=$ARCHIVE_DIR/README.md
    cat << EOF > $ATTEST_README
# yubikey attestation data

This archive contains data sufficient to verify the Yubikey attestation for
the key associated with $CA_CERT. Each file is discussed below. The relevant
yubico docs can be found here:
https://developers.yubico.com/PIV/Introduction/PIV_attestation.html
https://developers.yubico.com/yubico-piv-tool/Attestation.html

## $(basename $VERIFY_SH)
This script is an example of how a PIV attestation from a yubikey may be
verified. It obtains the root CA cert from yubico and then verifies the
signature on the leaf attestation cert through the intermediate CA (the CA
on the yubikey). Additionally this script extracts the public key from the
leaf attestation cert and checks to be sure the cert for our key is the same.

Additional checks and data may be useful or necessary depending on use-case.
For additional fields and data that may be used see:
https://developers.yubico.com/PIV/Introduction/PIV_attestation.html

## $(basename $CERT)
This file is the self-signed certificate for the encryption key generated on
our yubikey. Whether or not you trust this root CA cert depends on the results
of the attestation verification.

## $(basename $ATTEST_CERT)
This file holds the attestation (a leaf cert) for the key generated on our
yubikey. This cert is created by the yubikey and signed by the yubikey's
intermediate attestation cert.

## $(basename $ATTEST_INT_CERT)
This is the certificate for the intermediate attestation key on the yubikey.
This key is provisioned by yubico and it's cert is signed by the yubico
attestation root.

EOF

    tar --directory $TMP_DIR \
        --auto-compress \
        --create \
        --file $ARCHIVE_FILE \
        $ARCHIVE_PREFIX

    # extract archive we've created and run the verification script
    # local VERIFICATION_DIR=$TMP_DIR/verify
    # mkdir $VERIFICATION_DIR
    tar --directory $TMP_DIR \
        --auto-compress \
        --extract \
        --file $ARCHIVE_FILE
    pushd $TMP_DIR/$ARCHIVE_PREFIX > /dev/null
    ./$(basename $VERIFY_SH)
    if [ $? -ne 0 ]; then
        echo "failure"
        cat $LOG
        exit 1
    fi
    popd > /dev/null
}

do_selfsign_$YUBI

rm -rf $TMP_DIR
